// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"hrapi/internal/types"
	"strings"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"
)

func newCheckInStatus(db *gorm.DB, opts ...gen.DOOption) checkInStatus {
	_checkInStatus := checkInStatus{}

	_checkInStatus.checkInStatusDo.UseDB(db, opts...)
	_checkInStatus.checkInStatusDo.UseModel(&types.CheckInStatus{})

	tableName := _checkInStatus.checkInStatusDo.TableName()
	_checkInStatus.ALL = field.NewAsterisk(tableName)
	_checkInStatus.ID = field.NewUint(tableName, "id")
	_checkInStatus.CreatedAt = field.NewTime(tableName, "created_at")
	_checkInStatus.UpdatedAt = field.NewTime(tableName, "updated_at")
	_checkInStatus.DeletedAt = field.NewField(tableName, "deleted_at")
	_checkInStatus.EmployeeID = field.NewUint(tableName, "employee_id")
	_checkInStatus.WorkShiftID = field.NewUint(tableName, "work_shift_id")
	_checkInStatus.WorkCheckInDate = field.NewTime(tableName, "work_check_in_date")
	_checkInStatus.WorkAttendTime = field.NewTime(tableName, "work_attend_time")
	_checkInStatus.WorkAttendStatus = field.NewField(tableName, "work_attend_status")
	_checkInStatus.WorkAttendProcStatus = field.NewField(tableName, "work_attend_proc_status")
	_checkInStatus.OffWorkCheckInDate = field.NewTime(tableName, "off_work_check_in_date")
	_checkInStatus.OffWorkAttendTime = field.NewTime(tableName, "off_work_attend_time")
	_checkInStatus.OffWorkAttendStatus = field.NewField(tableName, "off_work_attend_status")
	_checkInStatus.OffWorkAttendProcStatus = field.NewField(tableName, "off_work_attend_proc_status")
	_checkInStatus.AbsenceHours = field.NewFloat32(tableName, "absence_hours")
	_checkInStatus.LeaveHours = field.NewFloat32(tableName, "leave_hours")
	_checkInStatus.SignLeaveHours = field.NewFloat32(tableName, "sign_leave_hours")
	_checkInStatus.OvertimeHours = field.NewFloat32(tableName, "overtime_hours")
	_checkInStatus.SignOvertimeHours = field.NewFloat32(tableName, "sign_overtime_hours")
	_checkInStatus.Employee = checkInStatusBelongsToEmployee{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Employee", "types.Employee"),
		Department: struct {
			field.RelationField
			Manager struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("Employee.Department", "types.Department"),
			Manager: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Employee.Department.Manager", "types.Employee"),
			},
		},
		Rank: struct {
			field.RelationField
			Grade struct {
				field.RelationField
				Rank struct {
					field.RelationField
				}
			}
		}{
			RelationField: field.NewRelation("Employee.Rank", "types.PositionRank"),
			Grade: struct {
				field.RelationField
				Rank struct {
					field.RelationField
				}
			}{
				RelationField: field.NewRelation("Employee.Rank.Grade", "types.PositionGrade"),
				Rank: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("Employee.Rank.Grade.Rank", "types.PositionRank"),
				},
			},
		},
		Grade: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("Employee.Grade", "types.PositionGrade"),
		},
		LoginInformation: struct {
			field.RelationField
			Employee struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("Employee.LoginInformation", "types.LoginInformation"),
			Employee: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Employee.LoginInformation.Employee", "types.Employee"),
			},
		},
		Roles: struct {
			field.RelationField
			Employees struct {
				field.RelationField
			}
			Permissions struct {
				field.RelationField
				Roles struct {
					field.RelationField
				}
			}
			Menus struct {
				field.RelationField
				Roles struct {
					field.RelationField
				}
			}
		}{
			RelationField: field.NewRelation("Employee.Roles", "types.Role"),
			Employees: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Employee.Roles.Employees", "types.Employee"),
			},
			Permissions: struct {
				field.RelationField
				Roles struct {
					field.RelationField
				}
			}{
				RelationField: field.NewRelation("Employee.Roles.Permissions", "types.Permission"),
				Roles: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("Employee.Roles.Permissions.Roles", "types.Role"),
				},
			},
			Menus: struct {
				field.RelationField
				Roles struct {
					field.RelationField
				}
			}{
				RelationField: field.NewRelation("Employee.Roles.Menus", "types.Menu"),
				Roles: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("Employee.Roles.Menus.Roles", "types.Role"),
				},
			},
		},
	}

	_checkInStatus.WorkShift = checkInStatusBelongsToWorkShift{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("WorkShift", "types.WorkShift"),
	}

	_checkInStatus.fillFieldMap()

	return _checkInStatus
}

type checkInStatus struct {
	checkInStatusDo checkInStatusDo

	ALL                     field.Asterisk
	ID                      field.Uint
	CreatedAt               field.Time
	UpdatedAt               field.Time
	DeletedAt               field.Field
	EmployeeID              field.Uint
	WorkShiftID             field.Uint
	WorkCheckInDate         field.Time
	WorkAttendTime          field.Time
	WorkAttendStatus        field.Field
	WorkAttendProcStatus    field.Field
	OffWorkCheckInDate      field.Time
	OffWorkAttendTime       field.Time
	OffWorkAttendStatus     field.Field
	OffWorkAttendProcStatus field.Field
	AbsenceHours            field.Float32
	LeaveHours              field.Float32
	SignLeaveHours          field.Float32
	OvertimeHours           field.Float32
	SignOvertimeHours       field.Float32
	Employee                checkInStatusBelongsToEmployee

	WorkShift checkInStatusBelongsToWorkShift

	fieldMap map[string]field.Expr
}

func (c checkInStatus) Table(newTableName string) *checkInStatus {
	c.checkInStatusDo.UseTable(newTableName)
	return c.updateTableName(newTableName)
}

func (c checkInStatus) As(alias string) *checkInStatus {
	c.checkInStatusDo.DO = *(c.checkInStatusDo.As(alias).(*gen.DO))
	return c.updateTableName(alias)
}

func (c *checkInStatus) updateTableName(table string) *checkInStatus {
	c.ALL = field.NewAsterisk(table)
	c.ID = field.NewUint(table, "id")
	c.CreatedAt = field.NewTime(table, "created_at")
	c.UpdatedAt = field.NewTime(table, "updated_at")
	c.DeletedAt = field.NewField(table, "deleted_at")
	c.EmployeeID = field.NewUint(table, "employee_id")
	c.WorkShiftID = field.NewUint(table, "work_shift_id")
	c.WorkCheckInDate = field.NewTime(table, "work_check_in_date")
	c.WorkAttendTime = field.NewTime(table, "work_attend_time")
	c.WorkAttendStatus = field.NewField(table, "work_attend_status")
	c.WorkAttendProcStatus = field.NewField(table, "work_attend_proc_status")
	c.OffWorkCheckInDate = field.NewTime(table, "off_work_check_in_date")
	c.OffWorkAttendTime = field.NewTime(table, "off_work_attend_time")
	c.OffWorkAttendStatus = field.NewField(table, "off_work_attend_status")
	c.OffWorkAttendProcStatus = field.NewField(table, "off_work_attend_proc_status")
	c.AbsenceHours = field.NewFloat32(table, "absence_hours")
	c.LeaveHours = field.NewFloat32(table, "leave_hours")
	c.SignLeaveHours = field.NewFloat32(table, "sign_leave_hours")
	c.OvertimeHours = field.NewFloat32(table, "overtime_hours")
	c.SignOvertimeHours = field.NewFloat32(table, "sign_overtime_hours")

	c.fillFieldMap()

	return c
}

func (c *checkInStatus) WithContext(ctx context.Context) ICheckInStatusDo {
	return c.checkInStatusDo.WithContext(ctx)
}

func (c checkInStatus) TableName() string { return c.checkInStatusDo.TableName() }

func (c checkInStatus) Alias() string { return c.checkInStatusDo.Alias() }

func (c checkInStatus) Columns(cols ...field.Expr) gen.Columns {
	return c.checkInStatusDo.Columns(cols...)
}

func (c *checkInStatus) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := c.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (c *checkInStatus) fillFieldMap() {
	c.fieldMap = make(map[string]field.Expr, 21)
	c.fieldMap["id"] = c.ID
	c.fieldMap["created_at"] = c.CreatedAt
	c.fieldMap["updated_at"] = c.UpdatedAt
	c.fieldMap["deleted_at"] = c.DeletedAt
	c.fieldMap["employee_id"] = c.EmployeeID
	c.fieldMap["work_shift_id"] = c.WorkShiftID
	c.fieldMap["work_check_in_date"] = c.WorkCheckInDate
	c.fieldMap["work_attend_time"] = c.WorkAttendTime
	c.fieldMap["work_attend_status"] = c.WorkAttendStatus
	c.fieldMap["work_attend_proc_status"] = c.WorkAttendProcStatus
	c.fieldMap["off_work_check_in_date"] = c.OffWorkCheckInDate
	c.fieldMap["off_work_attend_time"] = c.OffWorkAttendTime
	c.fieldMap["off_work_attend_status"] = c.OffWorkAttendStatus
	c.fieldMap["off_work_attend_proc_status"] = c.OffWorkAttendProcStatus
	c.fieldMap["absence_hours"] = c.AbsenceHours
	c.fieldMap["leave_hours"] = c.LeaveHours
	c.fieldMap["sign_leave_hours"] = c.SignLeaveHours
	c.fieldMap["overtime_hours"] = c.OvertimeHours
	c.fieldMap["sign_overtime_hours"] = c.SignOvertimeHours

}

func (c checkInStatus) clone(db *gorm.DB) checkInStatus {
	c.checkInStatusDo.ReplaceConnPool(db.Statement.ConnPool)
	return c
}

func (c checkInStatus) replaceDB(db *gorm.DB) checkInStatus {
	c.checkInStatusDo.ReplaceDB(db)
	return c
}

type checkInStatusBelongsToEmployee struct {
	db *gorm.DB

	field.RelationField

	Department struct {
		field.RelationField
		Manager struct {
			field.RelationField
		}
	}
	Rank struct {
		field.RelationField
		Grade struct {
			field.RelationField
			Rank struct {
				field.RelationField
			}
		}
	}
	Grade struct {
		field.RelationField
	}
	LoginInformation struct {
		field.RelationField
		Employee struct {
			field.RelationField
		}
	}
	Roles struct {
		field.RelationField
		Employees struct {
			field.RelationField
		}
		Permissions struct {
			field.RelationField
			Roles struct {
				field.RelationField
			}
		}
		Menus struct {
			field.RelationField
			Roles struct {
				field.RelationField
			}
		}
	}
}

func (a checkInStatusBelongsToEmployee) Where(conds ...field.Expr) *checkInStatusBelongsToEmployee {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a checkInStatusBelongsToEmployee) WithContext(ctx context.Context) *checkInStatusBelongsToEmployee {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a checkInStatusBelongsToEmployee) Session(session *gorm.Session) *checkInStatusBelongsToEmployee {
	a.db = a.db.Session(session)
	return &a
}

func (a checkInStatusBelongsToEmployee) Model(m *types.CheckInStatus) *checkInStatusBelongsToEmployeeTx {
	return &checkInStatusBelongsToEmployeeTx{a.db.Model(m).Association(a.Name())}
}

type checkInStatusBelongsToEmployeeTx struct{ tx *gorm.Association }

func (a checkInStatusBelongsToEmployeeTx) Find() (result *types.Employee, err error) {
	return result, a.tx.Find(&result)
}

func (a checkInStatusBelongsToEmployeeTx) Append(values ...*types.Employee) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a checkInStatusBelongsToEmployeeTx) Replace(values ...*types.Employee) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a checkInStatusBelongsToEmployeeTx) Delete(values ...*types.Employee) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a checkInStatusBelongsToEmployeeTx) Clear() error {
	return a.tx.Clear()
}

func (a checkInStatusBelongsToEmployeeTx) Count() int64 {
	return a.tx.Count()
}

type checkInStatusBelongsToWorkShift struct {
	db *gorm.DB

	field.RelationField
}

func (a checkInStatusBelongsToWorkShift) Where(conds ...field.Expr) *checkInStatusBelongsToWorkShift {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a checkInStatusBelongsToWorkShift) WithContext(ctx context.Context) *checkInStatusBelongsToWorkShift {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a checkInStatusBelongsToWorkShift) Session(session *gorm.Session) *checkInStatusBelongsToWorkShift {
	a.db = a.db.Session(session)
	return &a
}

func (a checkInStatusBelongsToWorkShift) Model(m *types.CheckInStatus) *checkInStatusBelongsToWorkShiftTx {
	return &checkInStatusBelongsToWorkShiftTx{a.db.Model(m).Association(a.Name())}
}

type checkInStatusBelongsToWorkShiftTx struct{ tx *gorm.Association }

func (a checkInStatusBelongsToWorkShiftTx) Find() (result *types.WorkShift, err error) {
	return result, a.tx.Find(&result)
}

func (a checkInStatusBelongsToWorkShiftTx) Append(values ...*types.WorkShift) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a checkInStatusBelongsToWorkShiftTx) Replace(values ...*types.WorkShift) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a checkInStatusBelongsToWorkShiftTx) Delete(values ...*types.WorkShift) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a checkInStatusBelongsToWorkShiftTx) Clear() error {
	return a.tx.Clear()
}

func (a checkInStatusBelongsToWorkShiftTx) Count() int64 {
	return a.tx.Count()
}

type checkInStatusDo struct{ gen.DO }

type ICheckInStatusDo interface {
	gen.SubQuery
	Debug() ICheckInStatusDo
	WithContext(ctx context.Context) ICheckInStatusDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ICheckInStatusDo
	WriteDB() ICheckInStatusDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ICheckInStatusDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ICheckInStatusDo
	Not(conds ...gen.Condition) ICheckInStatusDo
	Or(conds ...gen.Condition) ICheckInStatusDo
	Select(conds ...field.Expr) ICheckInStatusDo
	Where(conds ...gen.Condition) ICheckInStatusDo
	Order(conds ...field.Expr) ICheckInStatusDo
	Distinct(cols ...field.Expr) ICheckInStatusDo
	Omit(cols ...field.Expr) ICheckInStatusDo
	Join(table schema.Tabler, on ...field.Expr) ICheckInStatusDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ICheckInStatusDo
	RightJoin(table schema.Tabler, on ...field.Expr) ICheckInStatusDo
	Group(cols ...field.Expr) ICheckInStatusDo
	Having(conds ...gen.Condition) ICheckInStatusDo
	Limit(limit int) ICheckInStatusDo
	Offset(offset int) ICheckInStatusDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ICheckInStatusDo
	Unscoped() ICheckInStatusDo
	Create(values ...*types.CheckInStatus) error
	CreateInBatches(values []*types.CheckInStatus, batchSize int) error
	Save(values ...*types.CheckInStatus) error
	First() (*types.CheckInStatus, error)
	Take() (*types.CheckInStatus, error)
	Last() (*types.CheckInStatus, error)
	Find() ([]*types.CheckInStatus, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*types.CheckInStatus, err error)
	FindInBatches(result *[]*types.CheckInStatus, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*types.CheckInStatus) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ICheckInStatusDo
	Assign(attrs ...field.AssignExpr) ICheckInStatusDo
	Joins(fields ...field.RelationField) ICheckInStatusDo
	Preload(fields ...field.RelationField) ICheckInStatusDo
	FirstOrInit() (*types.CheckInStatus, error)
	FirstOrCreate() (*types.CheckInStatus, error)
	FindByPage(offset int, limit int) (result []*types.CheckInStatus, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ICheckInStatusDo
	UnderlyingDB() *gorm.DB
	schema.Tabler

	QueryByDateRangeAndEmpID(empID uint, dateOnly1 string, dateOnly2 string, abnormal bool) (result []*types.CheckInStatus, err error)
	DeleteByDate(dateOnly string) (rowsAffected int64, err error)
	DeleteByDateRange(dateOnly1 string, dateOnly2 string) (rowsAffected int64, err error)
	UpdateStatus(dateOnly string) (err error)
	UpdateTime(timeOnly string, dateOnly string, workShiftCode string, cardNum string, isWork bool) (rowsAffected int64, err error)
	QueryTotalAttendHours(empID uint, dateOnly1 string, dateOnly2 string) (result float32, err error)
	UpdateHourByLeave(empID uint, leaveRequestFromID uint) (err error)
	SubHourByLeave(empID uint, leaveRequestFromID uint) (err error)
}

// select * from @@table
//
//	   where work_check_in_date between @dateOnly1 and @dateOnly2 and
//	         employee_id = @empID and
//			 {{if abnormal}}
//	         	(work_attend_proc_status = 'not processed' or off_work_attend_proc_status = 'not processed') and
//				 {{end}}
//	         deleted_at is null
func (c checkInStatusDo) QueryByDateRangeAndEmpID(empID uint, dateOnly1 string, dateOnly2 string, abnormal bool) (result []*types.CheckInStatus, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, dateOnly1)
	params = append(params, dateOnly2)
	params = append(params, empID)
	generateSQL.WriteString("select * from check_in_status where work_check_in_date between ? and ? and employee_id = ? and ")
	if abnormal {
		generateSQL.WriteString("(work_attend_proc_status = 'not processed' or off_work_attend_proc_status = 'not processed') and ")
	}
	generateSQL.WriteString("deleted_at is null ")

	var executeSQL *gorm.DB
	executeSQL = c.UnderlyingDB().Raw(generateSQL.String(), params...).Find(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

// delete @@table where work_check_in_date = @dateOnly
func (c checkInStatusDo) DeleteByDate(dateOnly string) (rowsAffected int64, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, dateOnly)
	generateSQL.WriteString("delete check_in_status where work_check_in_date = ? ")

	var executeSQL *gorm.DB
	executeSQL = c.UnderlyingDB().Exec(generateSQL.String(), params...) // ignore_security_alert
	rowsAffected = executeSQL.RowsAffected
	err = executeSQL.Error

	return
}

// delete @@table where work_check_in_date between @dateOnly1 and @dateOnly2
func (c checkInStatusDo) DeleteByDateRange(dateOnly1 string, dateOnly2 string) (rowsAffected int64, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, dateOnly1)
	params = append(params, dateOnly2)
	generateSQL.WriteString("delete check_in_status where work_check_in_date between ? and ? ")

	var executeSQL *gorm.DB
	executeSQL = c.UnderlyingDB().Exec(generateSQL.String(), params...) // ignore_security_alert
	rowsAffected = executeSQL.RowsAffected
	err = executeSQL.Error

	return
}

// exec P_C_CheckInStatusUpdateStatus @dateOnly
func (c checkInStatusDo) UpdateStatus(dateOnly string) (err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, dateOnly)
	generateSQL.WriteString("exec P_C_CheckInStatusUpdateStatus ? ")

	var executeSQL *gorm.DB
	executeSQL = c.UnderlyingDB().Exec(generateSQL.String(), params...) // ignore_security_alert
	err = executeSQL.Error

	return
}

// update @@table
// {{if isWork}}
//
//	set work_attend_time = @timeOnly, updated_at = getdate()
//
// {{else}}
//
//	set off_work_attend_time = @timeOnly, updated_at = getdate()
//
// {{end}}
// where
//
//	work_shift_id = (select id from work_shift where code = @workShiftCode) and
//	employee_id = (select id from employee where card_number = @cardNum) and
//	{{if isWork}}
//	    work_check_in_date = @dateOnly
//	{{else}}
//	    off_work_check_in_date = @dateOnly
//	{{end}}
func (c checkInStatusDo) UpdateTime(timeOnly string, dateOnly string, workShiftCode string, cardNum string, isWork bool) (rowsAffected int64, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	generateSQL.WriteString("update check_in_status ")
	if isWork {
		params = append(params, timeOnly)
		generateSQL.WriteString("set work_attend_time = ?, updated_at = getdate() ")
	} else {
		params = append(params, timeOnly)
		generateSQL.WriteString("set off_work_attend_time = ?, updated_at = getdate() ")
	}
	params = append(params, workShiftCode)
	params = append(params, cardNum)
	generateSQL.WriteString("where work_shift_id = (select id from work_shift where code = ?) and employee_id = (select id from employee where card_number = ?) and ")
	if isWork {
		params = append(params, dateOnly)
		generateSQL.WriteString("work_check_in_date = ? ")
	} else {
		params = append(params, dateOnly)
		generateSQL.WriteString("off_work_check_in_date = ? ")
	}

	var executeSQL *gorm.DB
	executeSQL = c.UnderlyingDB().Exec(generateSQL.String(), params...) // ignore_security_alert
	rowsAffected = executeSQL.RowsAffected
	err = executeSQL.Error

	return
}

// select sum(w.total_hours) - sum(c.absence_hours) - sum(c.leave_hours) from check_in_status c
//
//	join work_shift w on (c.work_shift_id = w.id)
//	join employee e on (c.employee_id = e.id)
//
// where
//
//	c.work_shift_id != 0 and
//	work_check_in_date between @dateOnly1 and @dateOnly2 and
//	c.employee_id = @empID and
//	e.salary_cycle = 'hour'
func (c checkInStatusDo) QueryTotalAttendHours(empID uint, dateOnly1 string, dateOnly2 string) (result float32, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, dateOnly1)
	params = append(params, dateOnly2)
	params = append(params, empID)
	generateSQL.WriteString("select sum(w.total_hours) - sum(c.absence_hours) - sum(c.leave_hours) from check_in_status c join work_shift w on (c.work_shift_id = w.id) join employee e on (c.employee_id = e.id) where c.work_shift_id != 0 and work_check_in_date between ? and ? and c.employee_id = ? and e.salary_cycle = 'hour' ")

	var executeSQL *gorm.DB
	executeSQL = c.UnderlyingDB().Raw(generateSQL.String(), params...).Take(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

// exec P_C_CheckInHourUpdateByLeave @empID, @leaveRequestFromID
func (c checkInStatusDo) UpdateHourByLeave(empID uint, leaveRequestFromID uint) (err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, empID)
	params = append(params, leaveRequestFromID)
	generateSQL.WriteString("exec P_C_CheckInHourUpdateByLeave ?, ? ")

	var executeSQL *gorm.DB
	executeSQL = c.UnderlyingDB().Exec(generateSQL.String(), params...) // ignore_security_alert
	err = executeSQL.Error

	return
}

// exec P_C_CheckInHourSubByLeave @empID, @leaveRequestFromID
func (c checkInStatusDo) SubHourByLeave(empID uint, leaveRequestFromID uint) (err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, empID)
	params = append(params, leaveRequestFromID)
	generateSQL.WriteString("exec P_C_CheckInHourSubByLeave ?, ? ")

	var executeSQL *gorm.DB
	executeSQL = c.UnderlyingDB().Exec(generateSQL.String(), params...) // ignore_security_alert
	err = executeSQL.Error

	return
}

func (c checkInStatusDo) Debug() ICheckInStatusDo {
	return c.withDO(c.DO.Debug())
}

func (c checkInStatusDo) WithContext(ctx context.Context) ICheckInStatusDo {
	return c.withDO(c.DO.WithContext(ctx))
}

func (c checkInStatusDo) ReadDB() ICheckInStatusDo {
	return c.Clauses(dbresolver.Read)
}

func (c checkInStatusDo) WriteDB() ICheckInStatusDo {
	return c.Clauses(dbresolver.Write)
}

func (c checkInStatusDo) Session(config *gorm.Session) ICheckInStatusDo {
	return c.withDO(c.DO.Session(config))
}

func (c checkInStatusDo) Clauses(conds ...clause.Expression) ICheckInStatusDo {
	return c.withDO(c.DO.Clauses(conds...))
}

func (c checkInStatusDo) Returning(value interface{}, columns ...string) ICheckInStatusDo {
	return c.withDO(c.DO.Returning(value, columns...))
}

func (c checkInStatusDo) Not(conds ...gen.Condition) ICheckInStatusDo {
	return c.withDO(c.DO.Not(conds...))
}

func (c checkInStatusDo) Or(conds ...gen.Condition) ICheckInStatusDo {
	return c.withDO(c.DO.Or(conds...))
}

func (c checkInStatusDo) Select(conds ...field.Expr) ICheckInStatusDo {
	return c.withDO(c.DO.Select(conds...))
}

func (c checkInStatusDo) Where(conds ...gen.Condition) ICheckInStatusDo {
	return c.withDO(c.DO.Where(conds...))
}

func (c checkInStatusDo) Order(conds ...field.Expr) ICheckInStatusDo {
	return c.withDO(c.DO.Order(conds...))
}

func (c checkInStatusDo) Distinct(cols ...field.Expr) ICheckInStatusDo {
	return c.withDO(c.DO.Distinct(cols...))
}

func (c checkInStatusDo) Omit(cols ...field.Expr) ICheckInStatusDo {
	return c.withDO(c.DO.Omit(cols...))
}

func (c checkInStatusDo) Join(table schema.Tabler, on ...field.Expr) ICheckInStatusDo {
	return c.withDO(c.DO.Join(table, on...))
}

func (c checkInStatusDo) LeftJoin(table schema.Tabler, on ...field.Expr) ICheckInStatusDo {
	return c.withDO(c.DO.LeftJoin(table, on...))
}

func (c checkInStatusDo) RightJoin(table schema.Tabler, on ...field.Expr) ICheckInStatusDo {
	return c.withDO(c.DO.RightJoin(table, on...))
}

func (c checkInStatusDo) Group(cols ...field.Expr) ICheckInStatusDo {
	return c.withDO(c.DO.Group(cols...))
}

func (c checkInStatusDo) Having(conds ...gen.Condition) ICheckInStatusDo {
	return c.withDO(c.DO.Having(conds...))
}

func (c checkInStatusDo) Limit(limit int) ICheckInStatusDo {
	return c.withDO(c.DO.Limit(limit))
}

func (c checkInStatusDo) Offset(offset int) ICheckInStatusDo {
	return c.withDO(c.DO.Offset(offset))
}

func (c checkInStatusDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ICheckInStatusDo {
	return c.withDO(c.DO.Scopes(funcs...))
}

func (c checkInStatusDo) Unscoped() ICheckInStatusDo {
	return c.withDO(c.DO.Unscoped())
}

func (c checkInStatusDo) Create(values ...*types.CheckInStatus) error {
	if len(values) == 0 {
		return nil
	}
	return c.DO.Create(values)
}

func (c checkInStatusDo) CreateInBatches(values []*types.CheckInStatus, batchSize int) error {
	return c.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (c checkInStatusDo) Save(values ...*types.CheckInStatus) error {
	if len(values) == 0 {
		return nil
	}
	return c.DO.Save(values)
}

func (c checkInStatusDo) First() (*types.CheckInStatus, error) {
	if result, err := c.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*types.CheckInStatus), nil
	}
}

func (c checkInStatusDo) Take() (*types.CheckInStatus, error) {
	if result, err := c.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*types.CheckInStatus), nil
	}
}

func (c checkInStatusDo) Last() (*types.CheckInStatus, error) {
	if result, err := c.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*types.CheckInStatus), nil
	}
}

func (c checkInStatusDo) Find() ([]*types.CheckInStatus, error) {
	result, err := c.DO.Find()
	return result.([]*types.CheckInStatus), err
}

func (c checkInStatusDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*types.CheckInStatus, err error) {
	buf := make([]*types.CheckInStatus, 0, batchSize)
	err = c.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (c checkInStatusDo) FindInBatches(result *[]*types.CheckInStatus, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return c.DO.FindInBatches(result, batchSize, fc)
}

func (c checkInStatusDo) Attrs(attrs ...field.AssignExpr) ICheckInStatusDo {
	return c.withDO(c.DO.Attrs(attrs...))
}

func (c checkInStatusDo) Assign(attrs ...field.AssignExpr) ICheckInStatusDo {
	return c.withDO(c.DO.Assign(attrs...))
}

func (c checkInStatusDo) Joins(fields ...field.RelationField) ICheckInStatusDo {
	for _, _f := range fields {
		c = *c.withDO(c.DO.Joins(_f))
	}
	return &c
}

func (c checkInStatusDo) Preload(fields ...field.RelationField) ICheckInStatusDo {
	for _, _f := range fields {
		c = *c.withDO(c.DO.Preload(_f))
	}
	return &c
}

func (c checkInStatusDo) FirstOrInit() (*types.CheckInStatus, error) {
	if result, err := c.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*types.CheckInStatus), nil
	}
}

func (c checkInStatusDo) FirstOrCreate() (*types.CheckInStatus, error) {
	if result, err := c.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*types.CheckInStatus), nil
	}
}

func (c checkInStatusDo) FindByPage(offset int, limit int) (result []*types.CheckInStatus, count int64, err error) {
	result, err = c.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = c.Offset(-1).Limit(-1).Count()
	return
}

func (c checkInStatusDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = c.Count()
	if err != nil {
		return
	}

	err = c.Offset(offset).Limit(limit).Scan(result)
	return
}

func (c checkInStatusDo) Scan(result interface{}) (err error) {
	return c.DO.Scan(result)
}

func (c checkInStatusDo) Delete(models ...*types.CheckInStatus) (result gen.ResultInfo, err error) {
	return c.DO.Delete(models)
}

func (c *checkInStatusDo) withDO(do gen.Dao) *checkInStatusDo {
	c.DO = *do.(*gen.DO)
	return c
}
