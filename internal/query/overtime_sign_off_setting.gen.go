// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"hrapi/internal/types"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"
)

func newOvertimeSignOffSetting(db *gorm.DB, opts ...gen.DOOption) overtimeSignOffSetting {
	_overtimeSignOffSetting := overtimeSignOffSetting{}

	_overtimeSignOffSetting.overtimeSignOffSettingDo.UseDB(db, opts...)
	_overtimeSignOffSetting.overtimeSignOffSettingDo.UseModel(&types.OvertimeSignOffSetting{})

	tableName := _overtimeSignOffSetting.overtimeSignOffSettingDo.TableName()
	_overtimeSignOffSetting.ALL = field.NewAsterisk(tableName)
	_overtimeSignOffSetting.ID = field.NewUint(tableName, "id")
	_overtimeSignOffSetting.CreatedAt = field.NewTime(tableName, "created_at")
	_overtimeSignOffSetting.UpdatedAt = field.NewTime(tableName, "updated_at")
	_overtimeSignOffSetting.DeletedAt = field.NewField(tableName, "deleted_at")
	_overtimeSignOffSetting.DepartmentID = field.NewUint(tableName, "department_id")
	_overtimeSignOffSetting.VacationID = field.NewUint(tableName, "vacation_id")
	_overtimeSignOffSetting.Level = field.NewUint(tableName, "level")
	_overtimeSignOffSetting.GteHour = field.NewFloat32(tableName, "gte_hour")
	_overtimeSignOffSetting.SignType = field.NewField(tableName, "sign_type")
	_overtimeSignOffSetting.SpecificEmployeeID = field.NewUint(tableName, "specific_employee_id")
	_overtimeSignOffSetting.Notify = field.NewField(tableName, "notify")
	_overtimeSignOffSetting.Remark = field.NewString(tableName, "remark")
	_overtimeSignOffSetting.Department = overtimeSignOffSettingBelongsToDepartment{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Department", "types.Department"),
		Manager: struct {
			field.RelationField
			Department struct {
				field.RelationField
			}
			Rank struct {
				field.RelationField
				Grade struct {
					field.RelationField
					Rank struct {
						field.RelationField
					}
				}
			}
			Grade struct {
				field.RelationField
			}
			LoginInformation struct {
				field.RelationField
				Employee struct {
					field.RelationField
				}
			}
			Roles struct {
				field.RelationField
				Employees struct {
					field.RelationField
				}
				Permissions struct {
					field.RelationField
					Roles struct {
						field.RelationField
					}
				}
				Menus struct {
					field.RelationField
					Roles struct {
						field.RelationField
					}
				}
			}
		}{
			RelationField: field.NewRelation("Department.Manager", "types.Employee"),
			Department: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Department.Manager.Department", "types.Department"),
			},
			Rank: struct {
				field.RelationField
				Grade struct {
					field.RelationField
					Rank struct {
						field.RelationField
					}
				}
			}{
				RelationField: field.NewRelation("Department.Manager.Rank", "types.PositionRank"),
				Grade: struct {
					field.RelationField
					Rank struct {
						field.RelationField
					}
				}{
					RelationField: field.NewRelation("Department.Manager.Rank.Grade", "types.PositionGrade"),
					Rank: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("Department.Manager.Rank.Grade.Rank", "types.PositionRank"),
					},
				},
			},
			Grade: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Department.Manager.Grade", "types.PositionGrade"),
			},
			LoginInformation: struct {
				field.RelationField
				Employee struct {
					field.RelationField
				}
			}{
				RelationField: field.NewRelation("Department.Manager.LoginInformation", "types.LoginInformation"),
				Employee: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("Department.Manager.LoginInformation.Employee", "types.Employee"),
				},
			},
			Roles: struct {
				field.RelationField
				Employees struct {
					field.RelationField
				}
				Permissions struct {
					field.RelationField
					Roles struct {
						field.RelationField
					}
				}
				Menus struct {
					field.RelationField
					Roles struct {
						field.RelationField
					}
				}
			}{
				RelationField: field.NewRelation("Department.Manager.Roles", "types.Role"),
				Employees: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("Department.Manager.Roles.Employees", "types.Employee"),
				},
				Permissions: struct {
					field.RelationField
					Roles struct {
						field.RelationField
					}
				}{
					RelationField: field.NewRelation("Department.Manager.Roles.Permissions", "types.Permission"),
					Roles: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("Department.Manager.Roles.Permissions.Roles", "types.Role"),
					},
				},
				Menus: struct {
					field.RelationField
					Roles struct {
						field.RelationField
					}
				}{
					RelationField: field.NewRelation("Department.Manager.Roles.Menus", "types.Menu"),
					Roles: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("Department.Manager.Roles.Menus.Roles", "types.Role"),
					},
				},
			},
		},
	}

	_overtimeSignOffSetting.Vacation = overtimeSignOffSettingBelongsToVacation{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Vacation", "types.Vacation"),
		Schedule: struct {
			field.RelationField
			Vacation struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("Vacation.Schedule", "types.VacationSchedule"),
			Vacation: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Vacation.Schedule.Vacation", "types.Vacation"),
			},
		},
		VacationGroup: struct {
			field.RelationField
			Vacation struct {
				field.RelationField
			}
			VacationGroupOvertimeRate struct {
				field.RelationField
				VacationGroup struct {
					field.RelationField
					Leave struct {
						field.RelationField
						LeaveGroup struct {
							field.RelationField
						}
					}
					LeaveGroupCondition struct {
						field.RelationField
						LeaveGroup struct {
							field.RelationField
						}
					}
					Employee struct {
						field.RelationField
					}
				}
			}
			Employee struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("Vacation.VacationGroup", "types.VacationGroup"),
			Vacation: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Vacation.VacationGroup.Vacation", "types.Vacation"),
			},
			VacationGroupOvertimeRate: struct {
				field.RelationField
				VacationGroup struct {
					field.RelationField
					Leave struct {
						field.RelationField
						LeaveGroup struct {
							field.RelationField
						}
					}
					LeaveGroupCondition struct {
						field.RelationField
						LeaveGroup struct {
							field.RelationField
						}
					}
					Employee struct {
						field.RelationField
					}
				}
			}{
				RelationField: field.NewRelation("Vacation.VacationGroup.VacationGroupOvertimeRate", "types.VacationGroupOvertimeRate"),
				VacationGroup: struct {
					field.RelationField
					Leave struct {
						field.RelationField
						LeaveGroup struct {
							field.RelationField
						}
					}
					LeaveGroupCondition struct {
						field.RelationField
						LeaveGroup struct {
							field.RelationField
						}
					}
					Employee struct {
						field.RelationField
					}
				}{
					RelationField: field.NewRelation("Vacation.VacationGroup.VacationGroupOvertimeRate.VacationGroup", "types.LeaveGroup"),
					Leave: struct {
						field.RelationField
						LeaveGroup struct {
							field.RelationField
						}
					}{
						RelationField: field.NewRelation("Vacation.VacationGroup.VacationGroupOvertimeRate.VacationGroup.Leave", "types.Leave"),
						LeaveGroup: struct {
							field.RelationField
						}{
							RelationField: field.NewRelation("Vacation.VacationGroup.VacationGroupOvertimeRate.VacationGroup.Leave.LeaveGroup", "types.LeaveGroup"),
						},
					},
					LeaveGroupCondition: struct {
						field.RelationField
						LeaveGroup struct {
							field.RelationField
						}
					}{
						RelationField: field.NewRelation("Vacation.VacationGroup.VacationGroupOvertimeRate.VacationGroup.LeaveGroupCondition", "types.LeaveGroupCondition"),
						LeaveGroup: struct {
							field.RelationField
						}{
							RelationField: field.NewRelation("Vacation.VacationGroup.VacationGroupOvertimeRate.VacationGroup.LeaveGroupCondition.LeaveGroup", "types.LeaveGroup"),
						},
					},
					Employee: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("Vacation.VacationGroup.VacationGroupOvertimeRate.VacationGroup.Employee", "types.Employee"),
					},
				},
			},
			Employee: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Vacation.VacationGroup.Employee", "types.Employee"),
			},
		},
	}

	_overtimeSignOffSetting.SpecificEmployee = overtimeSignOffSettingBelongsToSpecificEmployee{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("SpecificEmployee", "types.Employee"),
	}

	_overtimeSignOffSetting.fillFieldMap()

	return _overtimeSignOffSetting
}

type overtimeSignOffSetting struct {
	overtimeSignOffSettingDo overtimeSignOffSettingDo

	ALL                field.Asterisk
	ID                 field.Uint
	CreatedAt          field.Time
	UpdatedAt          field.Time
	DeletedAt          field.Field
	DepartmentID       field.Uint
	VacationID         field.Uint
	Level              field.Uint
	GteHour            field.Float32
	SignType           field.Field
	SpecificEmployeeID field.Uint
	Notify             field.Field
	Remark             field.String
	Department         overtimeSignOffSettingBelongsToDepartment

	Vacation overtimeSignOffSettingBelongsToVacation

	SpecificEmployee overtimeSignOffSettingBelongsToSpecificEmployee

	fieldMap map[string]field.Expr
}

func (o overtimeSignOffSetting) Table(newTableName string) *overtimeSignOffSetting {
	o.overtimeSignOffSettingDo.UseTable(newTableName)
	return o.updateTableName(newTableName)
}

func (o overtimeSignOffSetting) As(alias string) *overtimeSignOffSetting {
	o.overtimeSignOffSettingDo.DO = *(o.overtimeSignOffSettingDo.As(alias).(*gen.DO))
	return o.updateTableName(alias)
}

func (o *overtimeSignOffSetting) updateTableName(table string) *overtimeSignOffSetting {
	o.ALL = field.NewAsterisk(table)
	o.ID = field.NewUint(table, "id")
	o.CreatedAt = field.NewTime(table, "created_at")
	o.UpdatedAt = field.NewTime(table, "updated_at")
	o.DeletedAt = field.NewField(table, "deleted_at")
	o.DepartmentID = field.NewUint(table, "department_id")
	o.VacationID = field.NewUint(table, "vacation_id")
	o.Level = field.NewUint(table, "level")
	o.GteHour = field.NewFloat32(table, "gte_hour")
	o.SignType = field.NewField(table, "sign_type")
	o.SpecificEmployeeID = field.NewUint(table, "specific_employee_id")
	o.Notify = field.NewField(table, "notify")
	o.Remark = field.NewString(table, "remark")

	o.fillFieldMap()

	return o
}

func (o *overtimeSignOffSetting) WithContext(ctx context.Context) IOvertimeSignOffSettingDo {
	return o.overtimeSignOffSettingDo.WithContext(ctx)
}

func (o overtimeSignOffSetting) TableName() string { return o.overtimeSignOffSettingDo.TableName() }

func (o overtimeSignOffSetting) Alias() string { return o.overtimeSignOffSettingDo.Alias() }

func (o overtimeSignOffSetting) Columns(cols ...field.Expr) gen.Columns {
	return o.overtimeSignOffSettingDo.Columns(cols...)
}

func (o *overtimeSignOffSetting) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := o.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (o *overtimeSignOffSetting) fillFieldMap() {
	o.fieldMap = make(map[string]field.Expr, 15)
	o.fieldMap["id"] = o.ID
	o.fieldMap["created_at"] = o.CreatedAt
	o.fieldMap["updated_at"] = o.UpdatedAt
	o.fieldMap["deleted_at"] = o.DeletedAt
	o.fieldMap["department_id"] = o.DepartmentID
	o.fieldMap["vacation_id"] = o.VacationID
	o.fieldMap["level"] = o.Level
	o.fieldMap["gte_hour"] = o.GteHour
	o.fieldMap["sign_type"] = o.SignType
	o.fieldMap["specific_employee_id"] = o.SpecificEmployeeID
	o.fieldMap["notify"] = o.Notify
	o.fieldMap["remark"] = o.Remark

}

func (o overtimeSignOffSetting) clone(db *gorm.DB) overtimeSignOffSetting {
	o.overtimeSignOffSettingDo.ReplaceConnPool(db.Statement.ConnPool)
	return o
}

func (o overtimeSignOffSetting) replaceDB(db *gorm.DB) overtimeSignOffSetting {
	o.overtimeSignOffSettingDo.ReplaceDB(db)
	return o
}

type overtimeSignOffSettingBelongsToDepartment struct {
	db *gorm.DB

	field.RelationField

	Manager struct {
		field.RelationField
		Department struct {
			field.RelationField
		}
		Rank struct {
			field.RelationField
			Grade struct {
				field.RelationField
				Rank struct {
					field.RelationField
				}
			}
		}
		Grade struct {
			field.RelationField
		}
		LoginInformation struct {
			field.RelationField
			Employee struct {
				field.RelationField
			}
		}
		Roles struct {
			field.RelationField
			Employees struct {
				field.RelationField
			}
			Permissions struct {
				field.RelationField
				Roles struct {
					field.RelationField
				}
			}
			Menus struct {
				field.RelationField
				Roles struct {
					field.RelationField
				}
			}
		}
	}
}

func (a overtimeSignOffSettingBelongsToDepartment) Where(conds ...field.Expr) *overtimeSignOffSettingBelongsToDepartment {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a overtimeSignOffSettingBelongsToDepartment) WithContext(ctx context.Context) *overtimeSignOffSettingBelongsToDepartment {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a overtimeSignOffSettingBelongsToDepartment) Session(session *gorm.Session) *overtimeSignOffSettingBelongsToDepartment {
	a.db = a.db.Session(session)
	return &a
}

func (a overtimeSignOffSettingBelongsToDepartment) Model(m *types.OvertimeSignOffSetting) *overtimeSignOffSettingBelongsToDepartmentTx {
	return &overtimeSignOffSettingBelongsToDepartmentTx{a.db.Model(m).Association(a.Name())}
}

type overtimeSignOffSettingBelongsToDepartmentTx struct{ tx *gorm.Association }

func (a overtimeSignOffSettingBelongsToDepartmentTx) Find() (result *types.Department, err error) {
	return result, a.tx.Find(&result)
}

func (a overtimeSignOffSettingBelongsToDepartmentTx) Append(values ...*types.Department) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a overtimeSignOffSettingBelongsToDepartmentTx) Replace(values ...*types.Department) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a overtimeSignOffSettingBelongsToDepartmentTx) Delete(values ...*types.Department) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a overtimeSignOffSettingBelongsToDepartmentTx) Clear() error {
	return a.tx.Clear()
}

func (a overtimeSignOffSettingBelongsToDepartmentTx) Count() int64 {
	return a.tx.Count()
}

type overtimeSignOffSettingBelongsToVacation struct {
	db *gorm.DB

	field.RelationField

	Schedule struct {
		field.RelationField
		Vacation struct {
			field.RelationField
		}
	}
	VacationGroup struct {
		field.RelationField
		Vacation struct {
			field.RelationField
		}
		VacationGroupOvertimeRate struct {
			field.RelationField
			VacationGroup struct {
				field.RelationField
				Leave struct {
					field.RelationField
					LeaveGroup struct {
						field.RelationField
					}
				}
				LeaveGroupCondition struct {
					field.RelationField
					LeaveGroup struct {
						field.RelationField
					}
				}
				Employee struct {
					field.RelationField
				}
			}
		}
		Employee struct {
			field.RelationField
		}
	}
}

func (a overtimeSignOffSettingBelongsToVacation) Where(conds ...field.Expr) *overtimeSignOffSettingBelongsToVacation {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a overtimeSignOffSettingBelongsToVacation) WithContext(ctx context.Context) *overtimeSignOffSettingBelongsToVacation {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a overtimeSignOffSettingBelongsToVacation) Session(session *gorm.Session) *overtimeSignOffSettingBelongsToVacation {
	a.db = a.db.Session(session)
	return &a
}

func (a overtimeSignOffSettingBelongsToVacation) Model(m *types.OvertimeSignOffSetting) *overtimeSignOffSettingBelongsToVacationTx {
	return &overtimeSignOffSettingBelongsToVacationTx{a.db.Model(m).Association(a.Name())}
}

type overtimeSignOffSettingBelongsToVacationTx struct{ tx *gorm.Association }

func (a overtimeSignOffSettingBelongsToVacationTx) Find() (result *types.Vacation, err error) {
	return result, a.tx.Find(&result)
}

func (a overtimeSignOffSettingBelongsToVacationTx) Append(values ...*types.Vacation) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a overtimeSignOffSettingBelongsToVacationTx) Replace(values ...*types.Vacation) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a overtimeSignOffSettingBelongsToVacationTx) Delete(values ...*types.Vacation) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a overtimeSignOffSettingBelongsToVacationTx) Clear() error {
	return a.tx.Clear()
}

func (a overtimeSignOffSettingBelongsToVacationTx) Count() int64 {
	return a.tx.Count()
}

type overtimeSignOffSettingBelongsToSpecificEmployee struct {
	db *gorm.DB

	field.RelationField
}

func (a overtimeSignOffSettingBelongsToSpecificEmployee) Where(conds ...field.Expr) *overtimeSignOffSettingBelongsToSpecificEmployee {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a overtimeSignOffSettingBelongsToSpecificEmployee) WithContext(ctx context.Context) *overtimeSignOffSettingBelongsToSpecificEmployee {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a overtimeSignOffSettingBelongsToSpecificEmployee) Session(session *gorm.Session) *overtimeSignOffSettingBelongsToSpecificEmployee {
	a.db = a.db.Session(session)
	return &a
}

func (a overtimeSignOffSettingBelongsToSpecificEmployee) Model(m *types.OvertimeSignOffSetting) *overtimeSignOffSettingBelongsToSpecificEmployeeTx {
	return &overtimeSignOffSettingBelongsToSpecificEmployeeTx{a.db.Model(m).Association(a.Name())}
}

type overtimeSignOffSettingBelongsToSpecificEmployeeTx struct{ tx *gorm.Association }

func (a overtimeSignOffSettingBelongsToSpecificEmployeeTx) Find() (result *types.Employee, err error) {
	return result, a.tx.Find(&result)
}

func (a overtimeSignOffSettingBelongsToSpecificEmployeeTx) Append(values ...*types.Employee) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a overtimeSignOffSettingBelongsToSpecificEmployeeTx) Replace(values ...*types.Employee) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a overtimeSignOffSettingBelongsToSpecificEmployeeTx) Delete(values ...*types.Employee) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a overtimeSignOffSettingBelongsToSpecificEmployeeTx) Clear() error {
	return a.tx.Clear()
}

func (a overtimeSignOffSettingBelongsToSpecificEmployeeTx) Count() int64 {
	return a.tx.Count()
}

type overtimeSignOffSettingDo struct{ gen.DO }

type IOvertimeSignOffSettingDo interface {
	gen.SubQuery
	Debug() IOvertimeSignOffSettingDo
	WithContext(ctx context.Context) IOvertimeSignOffSettingDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IOvertimeSignOffSettingDo
	WriteDB() IOvertimeSignOffSettingDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IOvertimeSignOffSettingDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IOvertimeSignOffSettingDo
	Not(conds ...gen.Condition) IOvertimeSignOffSettingDo
	Or(conds ...gen.Condition) IOvertimeSignOffSettingDo
	Select(conds ...field.Expr) IOvertimeSignOffSettingDo
	Where(conds ...gen.Condition) IOvertimeSignOffSettingDo
	Order(conds ...field.Expr) IOvertimeSignOffSettingDo
	Distinct(cols ...field.Expr) IOvertimeSignOffSettingDo
	Omit(cols ...field.Expr) IOvertimeSignOffSettingDo
	Join(table schema.Tabler, on ...field.Expr) IOvertimeSignOffSettingDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IOvertimeSignOffSettingDo
	RightJoin(table schema.Tabler, on ...field.Expr) IOvertimeSignOffSettingDo
	Group(cols ...field.Expr) IOvertimeSignOffSettingDo
	Having(conds ...gen.Condition) IOvertimeSignOffSettingDo
	Limit(limit int) IOvertimeSignOffSettingDo
	Offset(offset int) IOvertimeSignOffSettingDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IOvertimeSignOffSettingDo
	Unscoped() IOvertimeSignOffSettingDo
	Create(values ...*types.OvertimeSignOffSetting) error
	CreateInBatches(values []*types.OvertimeSignOffSetting, batchSize int) error
	Save(values ...*types.OvertimeSignOffSetting) error
	First() (*types.OvertimeSignOffSetting, error)
	Take() (*types.OvertimeSignOffSetting, error)
	Last() (*types.OvertimeSignOffSetting, error)
	Find() ([]*types.OvertimeSignOffSetting, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*types.OvertimeSignOffSetting, err error)
	FindInBatches(result *[]*types.OvertimeSignOffSetting, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*types.OvertimeSignOffSetting) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IOvertimeSignOffSettingDo
	Assign(attrs ...field.AssignExpr) IOvertimeSignOffSettingDo
	Joins(fields ...field.RelationField) IOvertimeSignOffSettingDo
	Preload(fields ...field.RelationField) IOvertimeSignOffSettingDo
	FirstOrInit() (*types.OvertimeSignOffSetting, error)
	FirstOrCreate() (*types.OvertimeSignOffSetting, error)
	FindByPage(offset int, limit int) (result []*types.OvertimeSignOffSetting, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IOvertimeSignOffSettingDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (o overtimeSignOffSettingDo) Debug() IOvertimeSignOffSettingDo {
	return o.withDO(o.DO.Debug())
}

func (o overtimeSignOffSettingDo) WithContext(ctx context.Context) IOvertimeSignOffSettingDo {
	return o.withDO(o.DO.WithContext(ctx))
}

func (o overtimeSignOffSettingDo) ReadDB() IOvertimeSignOffSettingDo {
	return o.Clauses(dbresolver.Read)
}

func (o overtimeSignOffSettingDo) WriteDB() IOvertimeSignOffSettingDo {
	return o.Clauses(dbresolver.Write)
}

func (o overtimeSignOffSettingDo) Session(config *gorm.Session) IOvertimeSignOffSettingDo {
	return o.withDO(o.DO.Session(config))
}

func (o overtimeSignOffSettingDo) Clauses(conds ...clause.Expression) IOvertimeSignOffSettingDo {
	return o.withDO(o.DO.Clauses(conds...))
}

func (o overtimeSignOffSettingDo) Returning(value interface{}, columns ...string) IOvertimeSignOffSettingDo {
	return o.withDO(o.DO.Returning(value, columns...))
}

func (o overtimeSignOffSettingDo) Not(conds ...gen.Condition) IOvertimeSignOffSettingDo {
	return o.withDO(o.DO.Not(conds...))
}

func (o overtimeSignOffSettingDo) Or(conds ...gen.Condition) IOvertimeSignOffSettingDo {
	return o.withDO(o.DO.Or(conds...))
}

func (o overtimeSignOffSettingDo) Select(conds ...field.Expr) IOvertimeSignOffSettingDo {
	return o.withDO(o.DO.Select(conds...))
}

func (o overtimeSignOffSettingDo) Where(conds ...gen.Condition) IOvertimeSignOffSettingDo {
	return o.withDO(o.DO.Where(conds...))
}

func (o overtimeSignOffSettingDo) Order(conds ...field.Expr) IOvertimeSignOffSettingDo {
	return o.withDO(o.DO.Order(conds...))
}

func (o overtimeSignOffSettingDo) Distinct(cols ...field.Expr) IOvertimeSignOffSettingDo {
	return o.withDO(o.DO.Distinct(cols...))
}

func (o overtimeSignOffSettingDo) Omit(cols ...field.Expr) IOvertimeSignOffSettingDo {
	return o.withDO(o.DO.Omit(cols...))
}

func (o overtimeSignOffSettingDo) Join(table schema.Tabler, on ...field.Expr) IOvertimeSignOffSettingDo {
	return o.withDO(o.DO.Join(table, on...))
}

func (o overtimeSignOffSettingDo) LeftJoin(table schema.Tabler, on ...field.Expr) IOvertimeSignOffSettingDo {
	return o.withDO(o.DO.LeftJoin(table, on...))
}

func (o overtimeSignOffSettingDo) RightJoin(table schema.Tabler, on ...field.Expr) IOvertimeSignOffSettingDo {
	return o.withDO(o.DO.RightJoin(table, on...))
}

func (o overtimeSignOffSettingDo) Group(cols ...field.Expr) IOvertimeSignOffSettingDo {
	return o.withDO(o.DO.Group(cols...))
}

func (o overtimeSignOffSettingDo) Having(conds ...gen.Condition) IOvertimeSignOffSettingDo {
	return o.withDO(o.DO.Having(conds...))
}

func (o overtimeSignOffSettingDo) Limit(limit int) IOvertimeSignOffSettingDo {
	return o.withDO(o.DO.Limit(limit))
}

func (o overtimeSignOffSettingDo) Offset(offset int) IOvertimeSignOffSettingDo {
	return o.withDO(o.DO.Offset(offset))
}

func (o overtimeSignOffSettingDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IOvertimeSignOffSettingDo {
	return o.withDO(o.DO.Scopes(funcs...))
}

func (o overtimeSignOffSettingDo) Unscoped() IOvertimeSignOffSettingDo {
	return o.withDO(o.DO.Unscoped())
}

func (o overtimeSignOffSettingDo) Create(values ...*types.OvertimeSignOffSetting) error {
	if len(values) == 0 {
		return nil
	}
	return o.DO.Create(values)
}

func (o overtimeSignOffSettingDo) CreateInBatches(values []*types.OvertimeSignOffSetting, batchSize int) error {
	return o.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (o overtimeSignOffSettingDo) Save(values ...*types.OvertimeSignOffSetting) error {
	if len(values) == 0 {
		return nil
	}
	return o.DO.Save(values)
}

func (o overtimeSignOffSettingDo) First() (*types.OvertimeSignOffSetting, error) {
	if result, err := o.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*types.OvertimeSignOffSetting), nil
	}
}

func (o overtimeSignOffSettingDo) Take() (*types.OvertimeSignOffSetting, error) {
	if result, err := o.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*types.OvertimeSignOffSetting), nil
	}
}

func (o overtimeSignOffSettingDo) Last() (*types.OvertimeSignOffSetting, error) {
	if result, err := o.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*types.OvertimeSignOffSetting), nil
	}
}

func (o overtimeSignOffSettingDo) Find() ([]*types.OvertimeSignOffSetting, error) {
	result, err := o.DO.Find()
	return result.([]*types.OvertimeSignOffSetting), err
}

func (o overtimeSignOffSettingDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*types.OvertimeSignOffSetting, err error) {
	buf := make([]*types.OvertimeSignOffSetting, 0, batchSize)
	err = o.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (o overtimeSignOffSettingDo) FindInBatches(result *[]*types.OvertimeSignOffSetting, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return o.DO.FindInBatches(result, batchSize, fc)
}

func (o overtimeSignOffSettingDo) Attrs(attrs ...field.AssignExpr) IOvertimeSignOffSettingDo {
	return o.withDO(o.DO.Attrs(attrs...))
}

func (o overtimeSignOffSettingDo) Assign(attrs ...field.AssignExpr) IOvertimeSignOffSettingDo {
	return o.withDO(o.DO.Assign(attrs...))
}

func (o overtimeSignOffSettingDo) Joins(fields ...field.RelationField) IOvertimeSignOffSettingDo {
	for _, _f := range fields {
		o = *o.withDO(o.DO.Joins(_f))
	}
	return &o
}

func (o overtimeSignOffSettingDo) Preload(fields ...field.RelationField) IOvertimeSignOffSettingDo {
	for _, _f := range fields {
		o = *o.withDO(o.DO.Preload(_f))
	}
	return &o
}

func (o overtimeSignOffSettingDo) FirstOrInit() (*types.OvertimeSignOffSetting, error) {
	if result, err := o.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*types.OvertimeSignOffSetting), nil
	}
}

func (o overtimeSignOffSettingDo) FirstOrCreate() (*types.OvertimeSignOffSetting, error) {
	if result, err := o.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*types.OvertimeSignOffSetting), nil
	}
}

func (o overtimeSignOffSettingDo) FindByPage(offset int, limit int) (result []*types.OvertimeSignOffSetting, count int64, err error) {
	result, err = o.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = o.Offset(-1).Limit(-1).Count()
	return
}

func (o overtimeSignOffSettingDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = o.Count()
	if err != nil {
		return
	}

	err = o.Offset(offset).Limit(limit).Scan(result)
	return
}

func (o overtimeSignOffSettingDo) Scan(result interface{}) (err error) {
	return o.DO.Scan(result)
}

func (o overtimeSignOffSettingDo) Delete(models ...*types.OvertimeSignOffSetting) (result gen.ResultInfo, err error) {
	return o.DO.Delete(models)
}

func (o *overtimeSignOffSettingDo) withDO(do gen.Dao) *overtimeSignOffSettingDo {
	o.DO = *do.(*gen.DO)
	return o
}
