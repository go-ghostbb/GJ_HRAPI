// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"hrapi/internal/types"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"
)

func newLeaveGroup(db *gorm.DB, opts ...gen.DOOption) leaveGroup {
	_leaveGroup := leaveGroup{}

	_leaveGroup.leaveGroupDo.UseDB(db, opts...)
	_leaveGroup.leaveGroupDo.UseModel(&types.LeaveGroup{})

	tableName := _leaveGroup.leaveGroupDo.TableName()
	_leaveGroup.ALL = field.NewAsterisk(tableName)
	_leaveGroup.ID = field.NewUint(tableName, "id")
	_leaveGroup.CreatedAt = field.NewTime(tableName, "created_at")
	_leaveGroup.UpdatedAt = field.NewTime(tableName, "updated_at")
	_leaveGroup.DeletedAt = field.NewField(tableName, "deleted_at")
	_leaveGroup.LeaveID = field.NewUint(tableName, "leave_id")
	_leaveGroup.Name = field.NewString(tableName, "name")
	_leaveGroup.LeaveGroupCondition = leaveGroupHasManyLeaveGroupCondition{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("LeaveGroupCondition", "types.LeaveGroupCondition"),
		LeaveGroup: struct {
			field.RelationField
			Leave struct {
				field.RelationField
				LeaveGroup struct {
					field.RelationField
				}
			}
			LeaveGroupCondition struct {
				field.RelationField
			}
			Employee struct {
				field.RelationField
				Department struct {
					field.RelationField
					Manager struct {
						field.RelationField
					}
				}
				LoginInformation struct {
					field.RelationField
					Employee struct {
						field.RelationField
					}
				}
				Roles struct {
					field.RelationField
					Employees struct {
						field.RelationField
					}
					Permissions struct {
						field.RelationField
						Roles struct {
							field.RelationField
						}
					}
					Menus struct {
						field.RelationField
						Roles struct {
							field.RelationField
						}
					}
				}
			}
		}{
			RelationField: field.NewRelation("LeaveGroupCondition.LeaveGroup", "types.LeaveGroup"),
			Leave: struct {
				field.RelationField
				LeaveGroup struct {
					field.RelationField
				}
			}{
				RelationField: field.NewRelation("LeaveGroupCondition.LeaveGroup.Leave", "types.Leave"),
				LeaveGroup: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("LeaveGroupCondition.LeaveGroup.Leave.LeaveGroup", "types.LeaveGroup"),
				},
			},
			LeaveGroupCondition: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("LeaveGroupCondition.LeaveGroup.LeaveGroupCondition", "types.LeaveGroupCondition"),
			},
			Employee: struct {
				field.RelationField
				Department struct {
					field.RelationField
					Manager struct {
						field.RelationField
					}
				}
				LoginInformation struct {
					field.RelationField
					Employee struct {
						field.RelationField
					}
				}
				Roles struct {
					field.RelationField
					Employees struct {
						field.RelationField
					}
					Permissions struct {
						field.RelationField
						Roles struct {
							field.RelationField
						}
					}
					Menus struct {
						field.RelationField
						Roles struct {
							field.RelationField
						}
					}
				}
			}{
				RelationField: field.NewRelation("LeaveGroupCondition.LeaveGroup.Employee", "types.Employee"),
				Department: struct {
					field.RelationField
					Manager struct {
						field.RelationField
					}
				}{
					RelationField: field.NewRelation("LeaveGroupCondition.LeaveGroup.Employee.Department", "types.Department"),
					Manager: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("LeaveGroupCondition.LeaveGroup.Employee.Department.Manager", "types.Employee"),
					},
				},
				LoginInformation: struct {
					field.RelationField
					Employee struct {
						field.RelationField
					}
				}{
					RelationField: field.NewRelation("LeaveGroupCondition.LeaveGroup.Employee.LoginInformation", "types.LoginInformation"),
					Employee: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("LeaveGroupCondition.LeaveGroup.Employee.LoginInformation.Employee", "types.Employee"),
					},
				},
				Roles: struct {
					field.RelationField
					Employees struct {
						field.RelationField
					}
					Permissions struct {
						field.RelationField
						Roles struct {
							field.RelationField
						}
					}
					Menus struct {
						field.RelationField
						Roles struct {
							field.RelationField
						}
					}
				}{
					RelationField: field.NewRelation("LeaveGroupCondition.LeaveGroup.Employee.Roles", "types.Role"),
					Employees: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("LeaveGroupCondition.LeaveGroup.Employee.Roles.Employees", "types.Employee"),
					},
					Permissions: struct {
						field.RelationField
						Roles struct {
							field.RelationField
						}
					}{
						RelationField: field.NewRelation("LeaveGroupCondition.LeaveGroup.Employee.Roles.Permissions", "types.Permission"),
						Roles: struct {
							field.RelationField
						}{
							RelationField: field.NewRelation("LeaveGroupCondition.LeaveGroup.Employee.Roles.Permissions.Roles", "types.Role"),
						},
					},
					Menus: struct {
						field.RelationField
						Roles struct {
							field.RelationField
						}
					}{
						RelationField: field.NewRelation("LeaveGroupCondition.LeaveGroup.Employee.Roles.Menus", "types.Menu"),
						Roles: struct {
							field.RelationField
						}{
							RelationField: field.NewRelation("LeaveGroupCondition.LeaveGroup.Employee.Roles.Menus.Roles", "types.Role"),
						},
					},
				},
			},
		},
	}

	_leaveGroup.Leave = leaveGroupBelongsToLeave{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Leave", "types.Leave"),
	}

	_leaveGroup.Employee = leaveGroupManyToManyEmployee{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Employee", "types.Employee"),
	}

	_leaveGroup.fillFieldMap()

	return _leaveGroup
}

type leaveGroup struct {
	leaveGroupDo leaveGroupDo

	ALL                 field.Asterisk
	ID                  field.Uint
	CreatedAt           field.Time
	UpdatedAt           field.Time
	DeletedAt           field.Field
	LeaveID             field.Uint
	Name                field.String
	LeaveGroupCondition leaveGroupHasManyLeaveGroupCondition

	Leave leaveGroupBelongsToLeave

	Employee leaveGroupManyToManyEmployee

	fieldMap map[string]field.Expr
}

func (l leaveGroup) Table(newTableName string) *leaveGroup {
	l.leaveGroupDo.UseTable(newTableName)
	return l.updateTableName(newTableName)
}

func (l leaveGroup) As(alias string) *leaveGroup {
	l.leaveGroupDo.DO = *(l.leaveGroupDo.As(alias).(*gen.DO))
	return l.updateTableName(alias)
}

func (l *leaveGroup) updateTableName(table string) *leaveGroup {
	l.ALL = field.NewAsterisk(table)
	l.ID = field.NewUint(table, "id")
	l.CreatedAt = field.NewTime(table, "created_at")
	l.UpdatedAt = field.NewTime(table, "updated_at")
	l.DeletedAt = field.NewField(table, "deleted_at")
	l.LeaveID = field.NewUint(table, "leave_id")
	l.Name = field.NewString(table, "name")

	l.fillFieldMap()

	return l
}

func (l *leaveGroup) WithContext(ctx context.Context) ILeaveGroupDo {
	return l.leaveGroupDo.WithContext(ctx)
}

func (l leaveGroup) TableName() string { return l.leaveGroupDo.TableName() }

func (l leaveGroup) Alias() string { return l.leaveGroupDo.Alias() }

func (l leaveGroup) Columns(cols ...field.Expr) gen.Columns { return l.leaveGroupDo.Columns(cols...) }

func (l *leaveGroup) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := l.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (l *leaveGroup) fillFieldMap() {
	l.fieldMap = make(map[string]field.Expr, 9)
	l.fieldMap["id"] = l.ID
	l.fieldMap["created_at"] = l.CreatedAt
	l.fieldMap["updated_at"] = l.UpdatedAt
	l.fieldMap["deleted_at"] = l.DeletedAt
	l.fieldMap["leave_id"] = l.LeaveID
	l.fieldMap["name"] = l.Name

}

func (l leaveGroup) clone(db *gorm.DB) leaveGroup {
	l.leaveGroupDo.ReplaceConnPool(db.Statement.ConnPool)
	return l
}

func (l leaveGroup) replaceDB(db *gorm.DB) leaveGroup {
	l.leaveGroupDo.ReplaceDB(db)
	return l
}

type leaveGroupHasManyLeaveGroupCondition struct {
	db *gorm.DB

	field.RelationField

	LeaveGroup struct {
		field.RelationField
		Leave struct {
			field.RelationField
			LeaveGroup struct {
				field.RelationField
			}
		}
		LeaveGroupCondition struct {
			field.RelationField
		}
		Employee struct {
			field.RelationField
			Department struct {
				field.RelationField
				Manager struct {
					field.RelationField
				}
			}
			LoginInformation struct {
				field.RelationField
				Employee struct {
					field.RelationField
				}
			}
			Roles struct {
				field.RelationField
				Employees struct {
					field.RelationField
				}
				Permissions struct {
					field.RelationField
					Roles struct {
						field.RelationField
					}
				}
				Menus struct {
					field.RelationField
					Roles struct {
						field.RelationField
					}
				}
			}
		}
	}
}

func (a leaveGroupHasManyLeaveGroupCondition) Where(conds ...field.Expr) *leaveGroupHasManyLeaveGroupCondition {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a leaveGroupHasManyLeaveGroupCondition) WithContext(ctx context.Context) *leaveGroupHasManyLeaveGroupCondition {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a leaveGroupHasManyLeaveGroupCondition) Session(session *gorm.Session) *leaveGroupHasManyLeaveGroupCondition {
	a.db = a.db.Session(session)
	return &a
}

func (a leaveGroupHasManyLeaveGroupCondition) Model(m *types.LeaveGroup) *leaveGroupHasManyLeaveGroupConditionTx {
	return &leaveGroupHasManyLeaveGroupConditionTx{a.db.Model(m).Association(a.Name())}
}

type leaveGroupHasManyLeaveGroupConditionTx struct{ tx *gorm.Association }

func (a leaveGroupHasManyLeaveGroupConditionTx) Find() (result []*types.LeaveGroupCondition, err error) {
	return result, a.tx.Find(&result)
}

func (a leaveGroupHasManyLeaveGroupConditionTx) Append(values ...*types.LeaveGroupCondition) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a leaveGroupHasManyLeaveGroupConditionTx) Replace(values ...*types.LeaveGroupCondition) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a leaveGroupHasManyLeaveGroupConditionTx) Delete(values ...*types.LeaveGroupCondition) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a leaveGroupHasManyLeaveGroupConditionTx) Clear() error {
	return a.tx.Clear()
}

func (a leaveGroupHasManyLeaveGroupConditionTx) Count() int64 {
	return a.tx.Count()
}

type leaveGroupBelongsToLeave struct {
	db *gorm.DB

	field.RelationField
}

func (a leaveGroupBelongsToLeave) Where(conds ...field.Expr) *leaveGroupBelongsToLeave {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a leaveGroupBelongsToLeave) WithContext(ctx context.Context) *leaveGroupBelongsToLeave {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a leaveGroupBelongsToLeave) Session(session *gorm.Session) *leaveGroupBelongsToLeave {
	a.db = a.db.Session(session)
	return &a
}

func (a leaveGroupBelongsToLeave) Model(m *types.LeaveGroup) *leaveGroupBelongsToLeaveTx {
	return &leaveGroupBelongsToLeaveTx{a.db.Model(m).Association(a.Name())}
}

type leaveGroupBelongsToLeaveTx struct{ tx *gorm.Association }

func (a leaveGroupBelongsToLeaveTx) Find() (result *types.Leave, err error) {
	return result, a.tx.Find(&result)
}

func (a leaveGroupBelongsToLeaveTx) Append(values ...*types.Leave) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a leaveGroupBelongsToLeaveTx) Replace(values ...*types.Leave) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a leaveGroupBelongsToLeaveTx) Delete(values ...*types.Leave) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a leaveGroupBelongsToLeaveTx) Clear() error {
	return a.tx.Clear()
}

func (a leaveGroupBelongsToLeaveTx) Count() int64 {
	return a.tx.Count()
}

type leaveGroupManyToManyEmployee struct {
	db *gorm.DB

	field.RelationField
}

func (a leaveGroupManyToManyEmployee) Where(conds ...field.Expr) *leaveGroupManyToManyEmployee {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a leaveGroupManyToManyEmployee) WithContext(ctx context.Context) *leaveGroupManyToManyEmployee {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a leaveGroupManyToManyEmployee) Session(session *gorm.Session) *leaveGroupManyToManyEmployee {
	a.db = a.db.Session(session)
	return &a
}

func (a leaveGroupManyToManyEmployee) Model(m *types.LeaveGroup) *leaveGroupManyToManyEmployeeTx {
	return &leaveGroupManyToManyEmployeeTx{a.db.Model(m).Association(a.Name())}
}

type leaveGroupManyToManyEmployeeTx struct{ tx *gorm.Association }

func (a leaveGroupManyToManyEmployeeTx) Find() (result []*types.Employee, err error) {
	return result, a.tx.Find(&result)
}

func (a leaveGroupManyToManyEmployeeTx) Append(values ...*types.Employee) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a leaveGroupManyToManyEmployeeTx) Replace(values ...*types.Employee) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a leaveGroupManyToManyEmployeeTx) Delete(values ...*types.Employee) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a leaveGroupManyToManyEmployeeTx) Clear() error {
	return a.tx.Clear()
}

func (a leaveGroupManyToManyEmployeeTx) Count() int64 {
	return a.tx.Count()
}

type leaveGroupDo struct{ gen.DO }

type ILeaveGroupDo interface {
	gen.SubQuery
	Debug() ILeaveGroupDo
	WithContext(ctx context.Context) ILeaveGroupDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ILeaveGroupDo
	WriteDB() ILeaveGroupDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ILeaveGroupDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ILeaveGroupDo
	Not(conds ...gen.Condition) ILeaveGroupDo
	Or(conds ...gen.Condition) ILeaveGroupDo
	Select(conds ...field.Expr) ILeaveGroupDo
	Where(conds ...gen.Condition) ILeaveGroupDo
	Order(conds ...field.Expr) ILeaveGroupDo
	Distinct(cols ...field.Expr) ILeaveGroupDo
	Omit(cols ...field.Expr) ILeaveGroupDo
	Join(table schema.Tabler, on ...field.Expr) ILeaveGroupDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ILeaveGroupDo
	RightJoin(table schema.Tabler, on ...field.Expr) ILeaveGroupDo
	Group(cols ...field.Expr) ILeaveGroupDo
	Having(conds ...gen.Condition) ILeaveGroupDo
	Limit(limit int) ILeaveGroupDo
	Offset(offset int) ILeaveGroupDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ILeaveGroupDo
	Unscoped() ILeaveGroupDo
	Create(values ...*types.LeaveGroup) error
	CreateInBatches(values []*types.LeaveGroup, batchSize int) error
	Save(values ...*types.LeaveGroup) error
	First() (*types.LeaveGroup, error)
	Take() (*types.LeaveGroup, error)
	Last() (*types.LeaveGroup, error)
	Find() ([]*types.LeaveGroup, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*types.LeaveGroup, err error)
	FindInBatches(result *[]*types.LeaveGroup, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*types.LeaveGroup) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ILeaveGroupDo
	Assign(attrs ...field.AssignExpr) ILeaveGroupDo
	Joins(fields ...field.RelationField) ILeaveGroupDo
	Preload(fields ...field.RelationField) ILeaveGroupDo
	FirstOrInit() (*types.LeaveGroup, error)
	FirstOrCreate() (*types.LeaveGroup, error)
	FindByPage(offset int, limit int) (result []*types.LeaveGroup, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ILeaveGroupDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (l leaveGroupDo) Debug() ILeaveGroupDo {
	return l.withDO(l.DO.Debug())
}

func (l leaveGroupDo) WithContext(ctx context.Context) ILeaveGroupDo {
	return l.withDO(l.DO.WithContext(ctx))
}

func (l leaveGroupDo) ReadDB() ILeaveGroupDo {
	return l.Clauses(dbresolver.Read)
}

func (l leaveGroupDo) WriteDB() ILeaveGroupDo {
	return l.Clauses(dbresolver.Write)
}

func (l leaveGroupDo) Session(config *gorm.Session) ILeaveGroupDo {
	return l.withDO(l.DO.Session(config))
}

func (l leaveGroupDo) Clauses(conds ...clause.Expression) ILeaveGroupDo {
	return l.withDO(l.DO.Clauses(conds...))
}

func (l leaveGroupDo) Returning(value interface{}, columns ...string) ILeaveGroupDo {
	return l.withDO(l.DO.Returning(value, columns...))
}

func (l leaveGroupDo) Not(conds ...gen.Condition) ILeaveGroupDo {
	return l.withDO(l.DO.Not(conds...))
}

func (l leaveGroupDo) Or(conds ...gen.Condition) ILeaveGroupDo {
	return l.withDO(l.DO.Or(conds...))
}

func (l leaveGroupDo) Select(conds ...field.Expr) ILeaveGroupDo {
	return l.withDO(l.DO.Select(conds...))
}

func (l leaveGroupDo) Where(conds ...gen.Condition) ILeaveGroupDo {
	return l.withDO(l.DO.Where(conds...))
}

func (l leaveGroupDo) Order(conds ...field.Expr) ILeaveGroupDo {
	return l.withDO(l.DO.Order(conds...))
}

func (l leaveGroupDo) Distinct(cols ...field.Expr) ILeaveGroupDo {
	return l.withDO(l.DO.Distinct(cols...))
}

func (l leaveGroupDo) Omit(cols ...field.Expr) ILeaveGroupDo {
	return l.withDO(l.DO.Omit(cols...))
}

func (l leaveGroupDo) Join(table schema.Tabler, on ...field.Expr) ILeaveGroupDo {
	return l.withDO(l.DO.Join(table, on...))
}

func (l leaveGroupDo) LeftJoin(table schema.Tabler, on ...field.Expr) ILeaveGroupDo {
	return l.withDO(l.DO.LeftJoin(table, on...))
}

func (l leaveGroupDo) RightJoin(table schema.Tabler, on ...field.Expr) ILeaveGroupDo {
	return l.withDO(l.DO.RightJoin(table, on...))
}

func (l leaveGroupDo) Group(cols ...field.Expr) ILeaveGroupDo {
	return l.withDO(l.DO.Group(cols...))
}

func (l leaveGroupDo) Having(conds ...gen.Condition) ILeaveGroupDo {
	return l.withDO(l.DO.Having(conds...))
}

func (l leaveGroupDo) Limit(limit int) ILeaveGroupDo {
	return l.withDO(l.DO.Limit(limit))
}

func (l leaveGroupDo) Offset(offset int) ILeaveGroupDo {
	return l.withDO(l.DO.Offset(offset))
}

func (l leaveGroupDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ILeaveGroupDo {
	return l.withDO(l.DO.Scopes(funcs...))
}

func (l leaveGroupDo) Unscoped() ILeaveGroupDo {
	return l.withDO(l.DO.Unscoped())
}

func (l leaveGroupDo) Create(values ...*types.LeaveGroup) error {
	if len(values) == 0 {
		return nil
	}
	return l.DO.Create(values)
}

func (l leaveGroupDo) CreateInBatches(values []*types.LeaveGroup, batchSize int) error {
	return l.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (l leaveGroupDo) Save(values ...*types.LeaveGroup) error {
	if len(values) == 0 {
		return nil
	}
	return l.DO.Save(values)
}

func (l leaveGroupDo) First() (*types.LeaveGroup, error) {
	if result, err := l.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*types.LeaveGroup), nil
	}
}

func (l leaveGroupDo) Take() (*types.LeaveGroup, error) {
	if result, err := l.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*types.LeaveGroup), nil
	}
}

func (l leaveGroupDo) Last() (*types.LeaveGroup, error) {
	if result, err := l.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*types.LeaveGroup), nil
	}
}

func (l leaveGroupDo) Find() ([]*types.LeaveGroup, error) {
	result, err := l.DO.Find()
	return result.([]*types.LeaveGroup), err
}

func (l leaveGroupDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*types.LeaveGroup, err error) {
	buf := make([]*types.LeaveGroup, 0, batchSize)
	err = l.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (l leaveGroupDo) FindInBatches(result *[]*types.LeaveGroup, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return l.DO.FindInBatches(result, batchSize, fc)
}

func (l leaveGroupDo) Attrs(attrs ...field.AssignExpr) ILeaveGroupDo {
	return l.withDO(l.DO.Attrs(attrs...))
}

func (l leaveGroupDo) Assign(attrs ...field.AssignExpr) ILeaveGroupDo {
	return l.withDO(l.DO.Assign(attrs...))
}

func (l leaveGroupDo) Joins(fields ...field.RelationField) ILeaveGroupDo {
	for _, _f := range fields {
		l = *l.withDO(l.DO.Joins(_f))
	}
	return &l
}

func (l leaveGroupDo) Preload(fields ...field.RelationField) ILeaveGroupDo {
	for _, _f := range fields {
		l = *l.withDO(l.DO.Preload(_f))
	}
	return &l
}

func (l leaveGroupDo) FirstOrInit() (*types.LeaveGroup, error) {
	if result, err := l.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*types.LeaveGroup), nil
	}
}

func (l leaveGroupDo) FirstOrCreate() (*types.LeaveGroup, error) {
	if result, err := l.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*types.LeaveGroup), nil
	}
}

func (l leaveGroupDo) FindByPage(offset int, limit int) (result []*types.LeaveGroup, count int64, err error) {
	result, err = l.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = l.Offset(-1).Limit(-1).Count()
	return
}

func (l leaveGroupDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = l.Count()
	if err != nil {
		return
	}

	err = l.Offset(offset).Limit(limit).Scan(result)
	return
}

func (l leaveGroupDo) Scan(result interface{}) (err error) {
	return l.DO.Scan(result)
}

func (l leaveGroupDo) Delete(models ...*types.LeaveGroup) (result gen.ResultInfo, err error) {
	return l.DO.Delete(models)
}

func (l *leaveGroupDo) withDO(do gen.Dao) *leaveGroupDo {
	l.DO = *do.(*gen.DO)
	return l
}
